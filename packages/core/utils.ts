// Utility functions for the AI Sales Agent application\n\nimport bcrypt from 'bcryptjs';\nimport { SECURITY } from './constants';\n\n// Password utilities\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SECURITY.PASSWORD_HASH_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n\n// String utilities\nexport function slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/[\\s_-]+/g, '-') // Replace spaces and underscores with hyphens\n    .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens\n}\n\nexport function capitalize(text: string): string {\n  return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();\n}\n\nexport function initials(firstName: string, lastName: string): string {\n  return `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase();\n}\n\nexport function truncate(text: string, length: number): string {\n  if (text.length <= length) return text;\n  return text.slice(0, length).trim() + '...';\n}\n\n// Email utilities\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nexport function extractDomainFromEmail(email: string): string {\n  return email.split('@')[1]?.toLowerCase() || '';\n}\n\nexport function maskEmail(email: string): string {\n  const [localPart, domain] = email.split('@');\n  if (localPart.length <= 2) return email;\n  \n  const maskedLocal = localPart.charAt(0) + '*'.repeat(localPart.length - 2) + localPart.slice(-1);\n  return `${maskedLocal}@${domain}`;\n}\n\n// URL utilities\nexport function isValidUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function extractDomainFromUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname.replace(/^www\\./i, '').toLowerCase();\n  } catch {\n    return '';\n  }\n}\n\nexport function addHttpsToUrl(url: string): string {\n  if (!url) return '';\n  if (url.startsWith('http://') || url.startsWith('https://')) {\n    return url;\n  }\n  return `https://${url}`;\n}\n\n// Date utilities\nexport function formatDate(date: Date, locale: string = 'en-US'): string {\n  return new Intl.DateTimeFormat(locale, {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n  }).format(date);\n}\n\nexport function formatDateTime(date: Date, locale: string = 'en-US'): string {\n  return new Intl.DateTimeFormat(locale, {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n  }).format(date);\n}\n\nexport function formatRelativeTime(date: Date, locale: string = 'en-US'): string {\n  const now = new Date();\n  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\n  \n  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });\n  \n  if (diffInSeconds < 60) {\n    return rtf.format(-diffInSeconds, 'second');\n  } else if (diffInSeconds < 3600) {\n    return rtf.format(-Math.floor(diffInSeconds / 60), 'minute');\n  } else if (diffInSeconds < 86400) {\n    return rtf.format(-Math.floor(diffInSeconds / 3600), 'hour');\n  } else if (diffInSeconds < 2592000) {\n    return rtf.format(-Math.floor(diffInSeconds / 86400), 'day');\n  } else if (diffInSeconds < 31536000) {\n    return rtf.format(-Math.floor(diffInSeconds / 2592000), 'month');\n  } else {\n    return rtf.format(-Math.floor(diffInSeconds / 31536000), 'year');\n  }\n}\n\nexport function addDays(date: Date, days: number): Date {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nexport function isToday(date: Date): boolean {\n  const today = new Date();\n  return date.toDateString() === today.toDateString();\n}\n\nexport function isThisWeek(date: Date): boolean {\n  const now = new Date();\n  const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));\n  const endOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + 6));\n  \n  return date >= startOfWeek && date <= endOfWeek;\n}\n\n// Number utilities\nexport function formatCurrency(amount: number, currency: string = 'USD', locale: string = 'en-US'): string {\n  return new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency,\n  }).format(amount);\n}\n\nexport function formatNumber(number: number, locale: string = 'en-US'): string {\n  return new Intl.NumberFormat(locale).format(number);\n}\n\nexport function formatPercentage(value: number, decimals: number = 1): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\n// Array utilities\nexport function unique<T>(array: T[]): T[] {\n  return Array.from(new Set(array));\n}\n\nexport function groupBy<T, K extends keyof any>(\n  array: T[],\n  getKey: (item: T) => K\n): Record<K, T[]> {\n  return array.reduce((groups, item) => {\n    const key = getKey(item);\n    const group = groups[key] || [];\n    group.push(item);\n    groups[key] = group;\n    return groups;\n  }, {} as Record<K, T[]>);\n}\n\nexport function sortBy<T>(array: T[], getKey: (item: T) => any, order: 'asc' | 'desc' = 'asc'): T[] {\n  return [...array].sort((a, b) => {\n    const aKey = getKey(a);\n    const bKey = getKey(b);\n    \n    if (aKey < bKey) return order === 'asc' ? -1 : 1;\n    if (aKey > bKey) return order === 'asc' ? 1 : -1;\n    return 0;\n  });\n}\n\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// Object utilities\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach(key => {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  });\n  return result;\n}\n\nexport function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n  keys.forEach(key => {\n    delete result[key];\n  });\n  return result;\n}\n\nexport function isEmpty(value: any): boolean {\n  if (value == null) return true;\n  if (Array.isArray(value) || typeof value === 'string') return value.length === 0;\n  if (typeof value === 'object') return Object.keys(value).length === 0;\n  return false;\n}\n\n// Validation utilities\nexport function isUUID(value: string): boolean {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(value);\n}\n\nexport function isStrongPassword(password: string): boolean {\n  // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character\n  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/;\n  return strongPasswordRegex.test(password);\n}\n\n// Random utilities\nexport function generateId(length: number = 8): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\nexport function generateRandomString(length: number): string {\n  const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return result;\n}\n\n// Sleep utility\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Retry utility\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    retries: number;\n    delay: number;\n    backoff?: number;\n  }\n): Promise<T> {\n  const { retries, delay, backoff = 1 } = options;\n  \n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await sleep(delay);\n      return retry(fn, {\n        retries: retries - 1,\n        delay: delay * backoff,\n        backoff,\n      });\n    }\n    throw error;\n  }\n}\n